// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  detectivePlace: (where?: DetectivePlaceWhereInput) => Promise<boolean>;
  log: (where?: LogWhereInput) => Promise<boolean>;
  transportation: (where?: TransportationWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  detectivePlace: (
    where: DetectivePlaceWhereUniqueInput
  ) => DetectivePlaceNullablePromise;
  detectivePlaces: (args?: {
    where?: DetectivePlaceWhereInput;
    orderBy?: DetectivePlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DetectivePlace>;
  detectivePlacesConnection: (args?: {
    where?: DetectivePlaceWhereInput;
    orderBy?: DetectivePlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DetectivePlaceConnectionPromise;
  log: (where: LogWhereUniqueInput) => LogNullablePromise;
  logs: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Log>;
  logsConnection: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LogConnectionPromise;
  transportation: (
    where: TransportationWhereUniqueInput
  ) => TransportationNullablePromise;
  transportations: (args?: {
    where?: TransportationWhereInput;
    orderBy?: TransportationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transportation>;
  transportationsConnection: (args?: {
    where?: TransportationWhereInput;
    orderBy?: TransportationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TransportationConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDetectivePlace: (
    data: DetectivePlaceCreateInput
  ) => DetectivePlacePromise;
  updateDetectivePlace: (args: {
    data: DetectivePlaceUpdateInput;
    where: DetectivePlaceWhereUniqueInput;
  }) => DetectivePlacePromise;
  updateManyDetectivePlaces: (args: {
    data: DetectivePlaceUpdateManyMutationInput;
    where?: DetectivePlaceWhereInput;
  }) => BatchPayloadPromise;
  upsertDetectivePlace: (args: {
    where: DetectivePlaceWhereUniqueInput;
    create: DetectivePlaceCreateInput;
    update: DetectivePlaceUpdateInput;
  }) => DetectivePlacePromise;
  deleteDetectivePlace: (
    where: DetectivePlaceWhereUniqueInput
  ) => DetectivePlacePromise;
  deleteManyDetectivePlaces: (
    where?: DetectivePlaceWhereInput
  ) => BatchPayloadPromise;
  createLog: (data: LogCreateInput) => LogPromise;
  updateLog: (args: {
    data: LogUpdateInput;
    where: LogWhereUniqueInput;
  }) => LogPromise;
  updateManyLogs: (args: {
    data: LogUpdateManyMutationInput;
    where?: LogWhereInput;
  }) => BatchPayloadPromise;
  upsertLog: (args: {
    where: LogWhereUniqueInput;
    create: LogCreateInput;
    update: LogUpdateInput;
  }) => LogPromise;
  deleteLog: (where: LogWhereUniqueInput) => LogPromise;
  deleteManyLogs: (where?: LogWhereInput) => BatchPayloadPromise;
  createTransportation: (
    data: TransportationCreateInput
  ) => TransportationPromise;
  updateTransportation: (args: {
    data: TransportationUpdateInput;
    where: TransportationWhereUniqueInput;
  }) => TransportationPromise;
  updateManyTransportations: (args: {
    data: TransportationUpdateManyMutationInput;
    where?: TransportationWhereInput;
  }) => BatchPayloadPromise;
  upsertTransportation: (args: {
    where: TransportationWhereUniqueInput;
    create: TransportationCreateInput;
    update: TransportationUpdateInput;
  }) => TransportationPromise;
  deleteTransportation: (
    where: TransportationWhereUniqueInput
  ) => TransportationPromise;
  deleteManyTransportations: (
    where?: TransportationWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  detectivePlace: (
    where?: DetectivePlaceSubscriptionWhereInput
  ) => DetectivePlaceSubscriptionPayloadSubscription;
  log: (
    where?: LogSubscriptionWhereInput
  ) => LogSubscriptionPayloadSubscription;
  transportation: (
    where?: TransportationSubscriptionWhereInput
  ) => TransportationSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TransportationType = "Bus" | "Subway";

export type DetectivePlaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "placeName_ASC"
  | "placeName_DESC"
  | "placeCode_ASC"
  | "placeCode_DESC";

export type LogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "detectiveCount_ASC"
  | "detectiveCount_DESC"
  | "placeName_ASC"
  | "placeName_DESC";

export type TransportationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "title_ASC"
  | "title_DESC"
  | "detectiveCount_ASC"
  | "detectiveCount_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DetectivePlaceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DetectivePlaceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  transportation?: Maybe<TransportationWhereInput>;
  placeName?: Maybe<String>;
  placeName_not?: Maybe<String>;
  placeName_in?: Maybe<String[] | String>;
  placeName_not_in?: Maybe<String[] | String>;
  placeName_lt?: Maybe<String>;
  placeName_lte?: Maybe<String>;
  placeName_gt?: Maybe<String>;
  placeName_gte?: Maybe<String>;
  placeName_contains?: Maybe<String>;
  placeName_not_contains?: Maybe<String>;
  placeName_starts_with?: Maybe<String>;
  placeName_not_starts_with?: Maybe<String>;
  placeName_ends_with?: Maybe<String>;
  placeName_not_ends_with?: Maybe<String>;
  placeCode?: Maybe<String>;
  placeCode_not?: Maybe<String>;
  placeCode_in?: Maybe<String[] | String>;
  placeCode_not_in?: Maybe<String[] | String>;
  placeCode_lt?: Maybe<String>;
  placeCode_lte?: Maybe<String>;
  placeCode_gt?: Maybe<String>;
  placeCode_gte?: Maybe<String>;
  placeCode_contains?: Maybe<String>;
  placeCode_not_contains?: Maybe<String>;
  placeCode_starts_with?: Maybe<String>;
  placeCode_not_starts_with?: Maybe<String>;
  placeCode_ends_with?: Maybe<String>;
  placeCode_not_ends_with?: Maybe<String>;
  AND?: Maybe<DetectivePlaceWhereInput[] | DetectivePlaceWhereInput>;
  OR?: Maybe<DetectivePlaceWhereInput[] | DetectivePlaceWhereInput>;
  NOT?: Maybe<DetectivePlaceWhereInput[] | DetectivePlaceWhereInput>;
}

export interface TransportationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<TransportationType>;
  type_not?: Maybe<TransportationType>;
  type_in?: Maybe<TransportationType[] | TransportationType>;
  type_not_in?: Maybe<TransportationType[] | TransportationType>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  detectiveCount?: Maybe<Int>;
  detectiveCount_not?: Maybe<Int>;
  detectiveCount_in?: Maybe<Int[] | Int>;
  detectiveCount_not_in?: Maybe<Int[] | Int>;
  detectiveCount_lt?: Maybe<Int>;
  detectiveCount_lte?: Maybe<Int>;
  detectiveCount_gt?: Maybe<Int>;
  detectiveCount_gte?: Maybe<Int>;
  AND?: Maybe<TransportationWhereInput[] | TransportationWhereInput>;
  OR?: Maybe<TransportationWhereInput[] | TransportationWhereInput>;
  NOT?: Maybe<TransportationWhereInput[] | TransportationWhereInput>;
}

export type LogWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LogWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  transportation?: Maybe<TransportationWhereInput>;
  detectiveCount?: Maybe<Int>;
  detectiveCount_not?: Maybe<Int>;
  detectiveCount_in?: Maybe<Int[] | Int>;
  detectiveCount_not_in?: Maybe<Int[] | Int>;
  detectiveCount_lt?: Maybe<Int>;
  detectiveCount_lte?: Maybe<Int>;
  detectiveCount_gt?: Maybe<Int>;
  detectiveCount_gte?: Maybe<Int>;
  placeName?: Maybe<String>;
  placeName_not?: Maybe<String>;
  placeName_in?: Maybe<String[] | String>;
  placeName_not_in?: Maybe<String[] | String>;
  placeName_lt?: Maybe<String>;
  placeName_lte?: Maybe<String>;
  placeName_gt?: Maybe<String>;
  placeName_gte?: Maybe<String>;
  placeName_contains?: Maybe<String>;
  placeName_not_contains?: Maybe<String>;
  placeName_starts_with?: Maybe<String>;
  placeName_not_starts_with?: Maybe<String>;
  placeName_ends_with?: Maybe<String>;
  placeName_not_ends_with?: Maybe<String>;
  AND?: Maybe<LogWhereInput[] | LogWhereInput>;
  OR?: Maybe<LogWhereInput[] | LogWhereInput>;
  NOT?: Maybe<LogWhereInput[] | LogWhereInput>;
}

export type TransportationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DetectivePlaceCreateInput {
  id?: Maybe<ID_Input>;
  transportation: TransportationCreateOneInput;
  placeName?: Maybe<String>;
  placeCode?: Maybe<String>;
}

export interface TransportationCreateOneInput {
  create?: Maybe<TransportationCreateInput>;
  connect?: Maybe<TransportationWhereUniqueInput>;
}

export interface TransportationCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<TransportationType>;
  title?: Maybe<String>;
  detectiveCount?: Maybe<Int>;
}

export interface DetectivePlaceUpdateInput {
  transportation?: Maybe<TransportationUpdateOneRequiredInput>;
  placeName?: Maybe<String>;
  placeCode?: Maybe<String>;
}

export interface TransportationUpdateOneRequiredInput {
  create?: Maybe<TransportationCreateInput>;
  update?: Maybe<TransportationUpdateDataInput>;
  upsert?: Maybe<TransportationUpsertNestedInput>;
  connect?: Maybe<TransportationWhereUniqueInput>;
}

export interface TransportationUpdateDataInput {
  type?: Maybe<TransportationType>;
  title?: Maybe<String>;
  detectiveCount?: Maybe<Int>;
}

export interface TransportationUpsertNestedInput {
  update: TransportationUpdateDataInput;
  create: TransportationCreateInput;
}

export interface DetectivePlaceUpdateManyMutationInput {
  placeName?: Maybe<String>;
  placeCode?: Maybe<String>;
}

export interface LogCreateInput {
  id?: Maybe<ID_Input>;
  transportation: TransportationCreateOneInput;
  detectiveCount?: Maybe<Int>;
  placeName?: Maybe<String>;
}

export interface LogUpdateInput {
  transportation?: Maybe<TransportationUpdateOneRequiredInput>;
  detectiveCount?: Maybe<Int>;
  placeName?: Maybe<String>;
}

export interface LogUpdateManyMutationInput {
  detectiveCount?: Maybe<Int>;
  placeName?: Maybe<String>;
}

export interface TransportationUpdateInput {
  type?: Maybe<TransportationType>;
  title?: Maybe<String>;
  detectiveCount?: Maybe<Int>;
}

export interface TransportationUpdateManyMutationInput {
  type?: Maybe<TransportationType>;
  title?: Maybe<String>;
  detectiveCount?: Maybe<Int>;
}

export interface DetectivePlaceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DetectivePlaceWhereInput>;
  AND?: Maybe<
    | DetectivePlaceSubscriptionWhereInput[]
    | DetectivePlaceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | DetectivePlaceSubscriptionWhereInput[]
    | DetectivePlaceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DetectivePlaceSubscriptionWhereInput[]
    | DetectivePlaceSubscriptionWhereInput
  >;
}

export interface LogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LogWhereInput>;
  AND?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
  OR?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
  NOT?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
}

export interface TransportationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TransportationWhereInput>;
  AND?: Maybe<
    | TransportationSubscriptionWhereInput[]
    | TransportationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | TransportationSubscriptionWhereInput[]
    | TransportationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TransportationSubscriptionWhereInput[]
    | TransportationSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface DetectivePlace {
  id: ID_Output;
  placeName?: String;
  placeCode?: String;
}

export interface DetectivePlacePromise
  extends Promise<DetectivePlace>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  transportation: <T = TransportationPromise>() => T;
  placeName: () => Promise<String>;
  placeCode: () => Promise<String>;
}

export interface DetectivePlaceSubscription
  extends Promise<AsyncIterator<DetectivePlace>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  transportation: <T = TransportationSubscription>() => T;
  placeName: () => Promise<AsyncIterator<String>>;
  placeCode: () => Promise<AsyncIterator<String>>;
}

export interface DetectivePlaceNullablePromise
  extends Promise<DetectivePlace | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  transportation: <T = TransportationPromise>() => T;
  placeName: () => Promise<String>;
  placeCode: () => Promise<String>;
}

export interface Transportation {
  id: ID_Output;
  type?: TransportationType;
  title?: String;
  detectiveCount?: Int;
}

export interface TransportationPromise
  extends Promise<Transportation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<TransportationType>;
  title: () => Promise<String>;
  detectiveCount: () => Promise<Int>;
}

export interface TransportationSubscription
  extends Promise<AsyncIterator<Transportation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<TransportationType>>;
  title: () => Promise<AsyncIterator<String>>;
  detectiveCount: () => Promise<AsyncIterator<Int>>;
}

export interface TransportationNullablePromise
  extends Promise<Transportation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<TransportationType>;
  title: () => Promise<String>;
  detectiveCount: () => Promise<Int>;
}

export interface DetectivePlaceConnection {
  pageInfo: PageInfo;
  edges: DetectivePlaceEdge[];
}

export interface DetectivePlaceConnectionPromise
  extends Promise<DetectivePlaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DetectivePlaceEdge>>() => T;
  aggregate: <T = AggregateDetectivePlacePromise>() => T;
}

export interface DetectivePlaceConnectionSubscription
  extends Promise<AsyncIterator<DetectivePlaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DetectivePlaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDetectivePlaceSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface DetectivePlaceEdge {
  node: DetectivePlace;
  cursor: String;
}

export interface DetectivePlaceEdgePromise
  extends Promise<DetectivePlaceEdge>,
    Fragmentable {
  node: <T = DetectivePlacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DetectivePlaceEdgeSubscription
  extends Promise<AsyncIterator<DetectivePlaceEdge>>,
    Fragmentable {
  node: <T = DetectivePlaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDetectivePlace {
  count: Int;
}

export interface AggregateDetectivePlacePromise
  extends Promise<AggregateDetectivePlace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDetectivePlaceSubscription
  extends Promise<AsyncIterator<AggregateDetectivePlace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Log {
  id: ID_Output;
  detectiveCount?: Int;
  placeName?: String;
}

export interface LogPromise extends Promise<Log>, Fragmentable {
  id: () => Promise<ID_Output>;
  transportation: <T = TransportationPromise>() => T;
  detectiveCount: () => Promise<Int>;
  placeName: () => Promise<String>;
}

export interface LogSubscription
  extends Promise<AsyncIterator<Log>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  transportation: <T = TransportationSubscription>() => T;
  detectiveCount: () => Promise<AsyncIterator<Int>>;
  placeName: () => Promise<AsyncIterator<String>>;
}

export interface LogNullablePromise extends Promise<Log | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  transportation: <T = TransportationPromise>() => T;
  detectiveCount: () => Promise<Int>;
  placeName: () => Promise<String>;
}

export interface LogConnection {
  pageInfo: PageInfo;
  edges: LogEdge[];
}

export interface LogConnectionPromise
  extends Promise<LogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LogEdge>>() => T;
  aggregate: <T = AggregateLogPromise>() => T;
}

export interface LogConnectionSubscription
  extends Promise<AsyncIterator<LogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLogSubscription>() => T;
}

export interface LogEdge {
  node: Log;
  cursor: String;
}

export interface LogEdgePromise extends Promise<LogEdge>, Fragmentable {
  node: <T = LogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LogEdgeSubscription
  extends Promise<AsyncIterator<LogEdge>>,
    Fragmentable {
  node: <T = LogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLog {
  count: Int;
}

export interface AggregateLogPromise
  extends Promise<AggregateLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLogSubscription
  extends Promise<AsyncIterator<AggregateLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransportationConnection {
  pageInfo: PageInfo;
  edges: TransportationEdge[];
}

export interface TransportationConnectionPromise
  extends Promise<TransportationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransportationEdge>>() => T;
  aggregate: <T = AggregateTransportationPromise>() => T;
}

export interface TransportationConnectionSubscription
  extends Promise<AsyncIterator<TransportationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransportationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransportationSubscription>() => T;
}

export interface TransportationEdge {
  node: Transportation;
  cursor: String;
}

export interface TransportationEdgePromise
  extends Promise<TransportationEdge>,
    Fragmentable {
  node: <T = TransportationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransportationEdgeSubscription
  extends Promise<AsyncIterator<TransportationEdge>>,
    Fragmentable {
  node: <T = TransportationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransportation {
  count: Int;
}

export interface AggregateTransportationPromise
  extends Promise<AggregateTransportation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransportationSubscription
  extends Promise<AsyncIterator<AggregateTransportation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DetectivePlaceSubscriptionPayload {
  mutation: MutationType;
  node: DetectivePlace;
  updatedFields: String[];
  previousValues: DetectivePlacePreviousValues;
}

export interface DetectivePlaceSubscriptionPayloadPromise
  extends Promise<DetectivePlaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DetectivePlacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DetectivePlacePreviousValuesPromise>() => T;
}

export interface DetectivePlaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DetectivePlaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DetectivePlaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DetectivePlacePreviousValuesSubscription>() => T;
}

export interface DetectivePlacePreviousValues {
  id: ID_Output;
  placeName?: String;
  placeCode?: String;
}

export interface DetectivePlacePreviousValuesPromise
  extends Promise<DetectivePlacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  placeName: () => Promise<String>;
  placeCode: () => Promise<String>;
}

export interface DetectivePlacePreviousValuesSubscription
  extends Promise<AsyncIterator<DetectivePlacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  placeName: () => Promise<AsyncIterator<String>>;
  placeCode: () => Promise<AsyncIterator<String>>;
}

export interface LogSubscriptionPayload {
  mutation: MutationType;
  node: Log;
  updatedFields: String[];
  previousValues: LogPreviousValues;
}

export interface LogSubscriptionPayloadPromise
  extends Promise<LogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LogPreviousValuesPromise>() => T;
}

export interface LogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LogPreviousValuesSubscription>() => T;
}

export interface LogPreviousValues {
  id: ID_Output;
  detectiveCount?: Int;
  placeName?: String;
}

export interface LogPreviousValuesPromise
  extends Promise<LogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  detectiveCount: () => Promise<Int>;
  placeName: () => Promise<String>;
}

export interface LogPreviousValuesSubscription
  extends Promise<AsyncIterator<LogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  detectiveCount: () => Promise<AsyncIterator<Int>>;
  placeName: () => Promise<AsyncIterator<String>>;
}

export interface TransportationSubscriptionPayload {
  mutation: MutationType;
  node: Transportation;
  updatedFields: String[];
  previousValues: TransportationPreviousValues;
}

export interface TransportationSubscriptionPayloadPromise
  extends Promise<TransportationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransportationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransportationPreviousValuesPromise>() => T;
}

export interface TransportationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransportationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransportationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransportationPreviousValuesSubscription>() => T;
}

export interface TransportationPreviousValues {
  id: ID_Output;
  type?: TransportationType;
  title?: String;
  detectiveCount?: Int;
}

export interface TransportationPreviousValuesPromise
  extends Promise<TransportationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<TransportationType>;
  title: () => Promise<String>;
  detectiveCount: () => Promise<Int>;
}

export interface TransportationPreviousValuesSubscription
  extends Promise<AsyncIterator<TransportationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<TransportationType>>;
  title: () => Promise<AsyncIterator<String>>;
  detectiveCount: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Transportation",
    embedded: false
  },
  {
    name: "TransportationType",
    embedded: false
  },
  {
    name: "DetectivePlace",
    embedded: false
  },
  {
    name: "Log",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
