module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateDetectivePlace {
  count: Int!
}

type AggregateLog {
  count: Int!
}

type AggregateTransportation {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type DetectivePlace {
  id: ID!
  transportation: Transportation!
  placeName: String
  placeCode: String
}

type DetectivePlaceConnection {
  pageInfo: PageInfo!
  edges: [DetectivePlaceEdge]!
  aggregate: AggregateDetectivePlace!
}

input DetectivePlaceCreateInput {
  id: ID
  transportation: TransportationCreateOneInput!
  placeName: String
  placeCode: String
}

type DetectivePlaceEdge {
  node: DetectivePlace!
  cursor: String!
}

enum DetectivePlaceOrderByInput {
  id_ASC
  id_DESC
  placeName_ASC
  placeName_DESC
  placeCode_ASC
  placeCode_DESC
}

type DetectivePlacePreviousValues {
  id: ID!
  placeName: String
  placeCode: String
}

type DetectivePlaceSubscriptionPayload {
  mutation: MutationType!
  node: DetectivePlace
  updatedFields: [String!]
  previousValues: DetectivePlacePreviousValues
}

input DetectivePlaceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DetectivePlaceWhereInput
  AND: [DetectivePlaceSubscriptionWhereInput!]
  OR: [DetectivePlaceSubscriptionWhereInput!]
  NOT: [DetectivePlaceSubscriptionWhereInput!]
}

input DetectivePlaceUpdateInput {
  transportation: TransportationUpdateOneRequiredInput
  placeName: String
  placeCode: String
}

input DetectivePlaceUpdateManyMutationInput {
  placeName: String
  placeCode: String
}

input DetectivePlaceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  transportation: TransportationWhereInput
  placeName: String
  placeName_not: String
  placeName_in: [String!]
  placeName_not_in: [String!]
  placeName_lt: String
  placeName_lte: String
  placeName_gt: String
  placeName_gte: String
  placeName_contains: String
  placeName_not_contains: String
  placeName_starts_with: String
  placeName_not_starts_with: String
  placeName_ends_with: String
  placeName_not_ends_with: String
  placeCode: String
  placeCode_not: String
  placeCode_in: [String!]
  placeCode_not_in: [String!]
  placeCode_lt: String
  placeCode_lte: String
  placeCode_gt: String
  placeCode_gte: String
  placeCode_contains: String
  placeCode_not_contains: String
  placeCode_starts_with: String
  placeCode_not_starts_with: String
  placeCode_ends_with: String
  placeCode_not_ends_with: String
  AND: [DetectivePlaceWhereInput!]
  OR: [DetectivePlaceWhereInput!]
  NOT: [DetectivePlaceWhereInput!]
}

input DetectivePlaceWhereUniqueInput {
  id: ID
}

type Log {
  id: ID!
  transportation: Transportation!
  detectiveCount: Int
  placeName: String
}

type LogConnection {
  pageInfo: PageInfo!
  edges: [LogEdge]!
  aggregate: AggregateLog!
}

input LogCreateInput {
  id: ID
  transportation: TransportationCreateOneInput!
  detectiveCount: Int
  placeName: String
}

type LogEdge {
  node: Log!
  cursor: String!
}

enum LogOrderByInput {
  id_ASC
  id_DESC
  detectiveCount_ASC
  detectiveCount_DESC
  placeName_ASC
  placeName_DESC
}

type LogPreviousValues {
  id: ID!
  detectiveCount: Int
  placeName: String
}

type LogSubscriptionPayload {
  mutation: MutationType!
  node: Log
  updatedFields: [String!]
  previousValues: LogPreviousValues
}

input LogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LogWhereInput
  AND: [LogSubscriptionWhereInput!]
  OR: [LogSubscriptionWhereInput!]
  NOT: [LogSubscriptionWhereInput!]
}

input LogUpdateInput {
  transportation: TransportationUpdateOneRequiredInput
  detectiveCount: Int
  placeName: String
}

input LogUpdateManyMutationInput {
  detectiveCount: Int
  placeName: String
}

input LogWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  transportation: TransportationWhereInput
  detectiveCount: Int
  detectiveCount_not: Int
  detectiveCount_in: [Int!]
  detectiveCount_not_in: [Int!]
  detectiveCount_lt: Int
  detectiveCount_lte: Int
  detectiveCount_gt: Int
  detectiveCount_gte: Int
  placeName: String
  placeName_not: String
  placeName_in: [String!]
  placeName_not_in: [String!]
  placeName_lt: String
  placeName_lte: String
  placeName_gt: String
  placeName_gte: String
  placeName_contains: String
  placeName_not_contains: String
  placeName_starts_with: String
  placeName_not_starts_with: String
  placeName_ends_with: String
  placeName_not_ends_with: String
  AND: [LogWhereInput!]
  OR: [LogWhereInput!]
  NOT: [LogWhereInput!]
}

input LogWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createDetectivePlace(data: DetectivePlaceCreateInput!): DetectivePlace!
  updateDetectivePlace(data: DetectivePlaceUpdateInput!, where: DetectivePlaceWhereUniqueInput!): DetectivePlace
  updateManyDetectivePlaces(data: DetectivePlaceUpdateManyMutationInput!, where: DetectivePlaceWhereInput): BatchPayload!
  upsertDetectivePlace(where: DetectivePlaceWhereUniqueInput!, create: DetectivePlaceCreateInput!, update: DetectivePlaceUpdateInput!): DetectivePlace!
  deleteDetectivePlace(where: DetectivePlaceWhereUniqueInput!): DetectivePlace
  deleteManyDetectivePlaces(where: DetectivePlaceWhereInput): BatchPayload!
  createLog(data: LogCreateInput!): Log!
  updateLog(data: LogUpdateInput!, where: LogWhereUniqueInput!): Log
  updateManyLogs(data: LogUpdateManyMutationInput!, where: LogWhereInput): BatchPayload!
  upsertLog(where: LogWhereUniqueInput!, create: LogCreateInput!, update: LogUpdateInput!): Log!
  deleteLog(where: LogWhereUniqueInput!): Log
  deleteManyLogs(where: LogWhereInput): BatchPayload!
  createTransportation(data: TransportationCreateInput!): Transportation!
  updateTransportation(data: TransportationUpdateInput!, where: TransportationWhereUniqueInput!): Transportation
  updateManyTransportations(data: TransportationUpdateManyMutationInput!, where: TransportationWhereInput): BatchPayload!
  upsertTransportation(where: TransportationWhereUniqueInput!, create: TransportationCreateInput!, update: TransportationUpdateInput!): Transportation!
  deleteTransportation(where: TransportationWhereUniqueInput!): Transportation
  deleteManyTransportations(where: TransportationWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  detectivePlace(where: DetectivePlaceWhereUniqueInput!): DetectivePlace
  detectivePlaces(where: DetectivePlaceWhereInput, orderBy: DetectivePlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DetectivePlace]!
  detectivePlacesConnection(where: DetectivePlaceWhereInput, orderBy: DetectivePlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DetectivePlaceConnection!
  log(where: LogWhereUniqueInput!): Log
  logs(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Log]!
  logsConnection(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LogConnection!
  transportation(where: TransportationWhereUniqueInput!): Transportation
  transportations(where: TransportationWhereInput, orderBy: TransportationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transportation]!
  transportationsConnection(where: TransportationWhereInput, orderBy: TransportationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransportationConnection!
  node(id: ID!): Node
}

type Subscription {
  detectivePlace(where: DetectivePlaceSubscriptionWhereInput): DetectivePlaceSubscriptionPayload
  log(where: LogSubscriptionWhereInput): LogSubscriptionPayload
  transportation(where: TransportationSubscriptionWhereInput): TransportationSubscriptionPayload
}

type Transportation {
  id: ID!
  type: TransportationType
  title: String
  detectiveCount: Int
}

type TransportationConnection {
  pageInfo: PageInfo!
  edges: [TransportationEdge]!
  aggregate: AggregateTransportation!
}

input TransportationCreateInput {
  id: ID
  type: TransportationType
  title: String
  detectiveCount: Int
}

input TransportationCreateOneInput {
  create: TransportationCreateInput
  connect: TransportationWhereUniqueInput
}

type TransportationEdge {
  node: Transportation!
  cursor: String!
}

enum TransportationOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  title_ASC
  title_DESC
  detectiveCount_ASC
  detectiveCount_DESC
}

type TransportationPreviousValues {
  id: ID!
  type: TransportationType
  title: String
  detectiveCount: Int
}

type TransportationSubscriptionPayload {
  mutation: MutationType!
  node: Transportation
  updatedFields: [String!]
  previousValues: TransportationPreviousValues
}

input TransportationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TransportationWhereInput
  AND: [TransportationSubscriptionWhereInput!]
  OR: [TransportationSubscriptionWhereInput!]
  NOT: [TransportationSubscriptionWhereInput!]
}

enum TransportationType {
  Bus
  Subway
}

input TransportationUpdateDataInput {
  type: TransportationType
  title: String
  detectiveCount: Int
}

input TransportationUpdateInput {
  type: TransportationType
  title: String
  detectiveCount: Int
}

input TransportationUpdateManyMutationInput {
  type: TransportationType
  title: String
  detectiveCount: Int
}

input TransportationUpdateOneRequiredInput {
  create: TransportationCreateInput
  update: TransportationUpdateDataInput
  upsert: TransportationUpsertNestedInput
  connect: TransportationWhereUniqueInput
}

input TransportationUpsertNestedInput {
  update: TransportationUpdateDataInput!
  create: TransportationCreateInput!
}

input TransportationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: TransportationType
  type_not: TransportationType
  type_in: [TransportationType!]
  type_not_in: [TransportationType!]
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  detectiveCount: Int
  detectiveCount_not: Int
  detectiveCount_in: [Int!]
  detectiveCount_not_in: [Int!]
  detectiveCount_lt: Int
  detectiveCount_lte: Int
  detectiveCount_gt: Int
  detectiveCount_gte: Int
  AND: [TransportationWhereInput!]
  OR: [TransportationWhereInput!]
  NOT: [TransportationWhereInput!]
}

input TransportationWhereUniqueInput {
  id: ID
}
`
      }
    